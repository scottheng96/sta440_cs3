---
title: "Election Prediction Report"
author: "Ashley Murray, Hunter Gregory, Matty Pahren, Nathan O'Hara, Scott Heng"
date: "10/29/2020"
output: pdf_document
---

```{r packages, include=FALSE}
library(tidyverse)
library(foreign)
library(gridExtra)
library(R2jags)
library(lme4)
library(merTools)
library(kableExtra)
library(brms)
```

# Introduction

Forecasting elections is of great interest, as politicians might use election outcome models to adjust campaign strategies, economists might use them to predict how markets will react, and citizens might use them to decide whether to vote. The 2020 election is one of great importance, and it has seemingly gained even more attention than past elections. 

In this report, we seek to model predicting the outcomes of several key races. Specifically, we aim to predict and provide uncertainty predictions for the following:
1. the outcome of the presidential election 
2. whether the US Senate remains in Republican control
3. the electoral college vote
4. the outcomes of all NC Congressional elections (the 13 federal Representatives to Congress)
5. the outcome of the NC Senate election

First, we will provide background on the elections and our data. Then, we will describe our methods for all of the models, including a model of who votes in North Carolina, which aims to better the predictive power of our NC senate and House models. Next, we will discuss the results of our models. After that, we will walk through some of the limitations of our models. Finally, the appendices will include more detailed information about our modeling procedures and the data sources used. 


# Background and Data
## Election Overview
On November 3, 2020, all 50 states will hold congressional elections for their respective Representatives as well as the presidential election between Donald Trump and Joe Biden. The senate currently has 53 Republican seats of 100 total seats, and senatorial elections across many states will determine 35 seats, 23 of which are currently under Republican control [[1]][Bibliography]. Overall, this election is clearly unprecedented due to the current pandemic since the “most severe pandemic in recent history” - the 1918 influenza - was over a century ago and not during a presidential election year [[2]][Bibliography]. It will be interesting to see if the dramatic increase in mail-in voting will favor different candidates or political parties. 

## Polling Data
We use polls extensively in nearly all our models. Specifically, we use FiveThirtyEight’s polling data for the presidential and US Senate races. We did not end up using these data for North Carolina’s elections for the House of Representatives since there were only three of thirteen districts with polls, and each of these districts only had two to four polls. 

<!-- Considering the different predictions this study is aiming to make, we draw data from multiple sources. Our datasets include Fivethirtyeight senate polling data, Fivethirtyeight presidential polling data, North Carolina Voter Data from the North Carolina voter registration database and National Census Data. Based on the question, we will draw information on different datasets, which will be explained more thoroughly at each model further in the report. -->

```{r, include=FALSE}
presidential_poll_averages_2020 <- read.csv("data/presidential_poll_averages_2020.csv") # note Maine and Nebraska are counted several times due to split electoral votes in this dataset
senate_polls <- read.csv("data/senate_polls.csv")

county_data <- read.csv(file = 'data/cty_covariates.csv') %>%
  filter(state == 37)
nc_counties <- read.csv(file = 'data/nc_county_data.csv')
nc_2016_data <- read.csv(file = 'data/2016_NC_data.csv') %>%
  mutate(county = X)
  
full_counties <- full_join(county_data, nc_counties, by = "county")
full_counties <- full_join(full_counties, nc_2016_data, by = "county") 
rep2016 <- read.csv(file='data/NC-counties-percent-republican-2016.csv')
rep2018 <- read.csv(file='data/NC-counties-percent-republican-2018.csv')
```

```{r, echo = FALSE}
# add incumbent data 

full_counties <- full_counties %>%
  mutate(incumbent_party = case_when(district == 1 ~ "DEM",
                                     district == 2 ~ "DEM",
                                     district == 3 ~ "REP",
                                     district == 4 ~ "DEM",
                                     district == 5 ~ "REP",
                                     district == 6 ~ "REP",
                                     district == 7 ~ "REP",
                                     district == 8 ~ "REP",
                                     district == 9 ~ "REP",
                                     district == 10 ~ "REP",
                                     district == 11 ~ "NONE",
                                     district == 12 ~ "DEM",
                                     district == 13 ~ "REP"))

rep2018 <- rep2018 %>%
  mutate(incumbent_party = case_when(district == 1 ~ "DEM",
                                     district == 2 ~ "DEM",
                                     district == 3 ~ "REP",
                                     district == 4 ~ "DEM",
                                     district == 5 ~ "REP",
                                     district == 6 ~ "REP",
                                     district == 7 ~ "REP",
                                     district == 8 ~ "REP",
                                     district == 9 ~ "REP",
                                     district == 10 ~ "REP",
                                     district == 11 ~ "NONE",
                                     district == 12 ~ "DEM",
                                     district == 13 ~ "REP"))

rep2016 <- rep2016 %>%
  mutate(incumbent_party = case_when(district == 1 ~ "DEM",
                                     district == 2 ~ "DEM",
                                     district == 3 ~ "REP",
                                     district == 4 ~ "DEM",
                                     district == 5 ~ "REP",
                                     district == 6 ~ "REP",
                                     district == 7 ~ "REP",
                                     district == 8 ~ "REP",
                                     district == 9 ~ "REP",
                                     district == 10 ~ "REP",
                                     district == 11 ~ "NONE",
                                     district == 12 ~ "DEM",
                                     district == 13 ~ "REP"))
```

```{r presidential-polls-by-state, include = FALSE}
p0 <- presidential_poll_averages_2020 %>%
  filter(state == "National") %>% ggplot(aes(x = as.Date(modeldate, format = "%m/%d/%y"), y = pct_estimate, color = candidate_name)) + geom_line() + labs(title = "National Polls", caption = "Fig 1.1 National Polls over time for Biden and Trump") + scale_colour_manual(values = c("Joseph R. Biden Jr." = "#123adb", "Donald Trump" = "#E01414", "Convention Bounce for Donald Trump" = "#ffb2ab","Convention Bounce for Joseph R. Biden Jr." =  "#abd1ff")) + xlab("Dates by Month (2020)") + ylab("Percentage estimate of being elected") + theme(plot.title = element_text(hjust = 0.5), , plot.caption = element_text(hjust = 0.5))

p1 <- presidential_poll_averages_2020 %>%
  filter(state != "National") %>% 
  filter(state != "ME-1") %>%
  filter(state != "ME-2") %>%
  filter(state != "NE-1") %>%
  filter(state != "NE-2") %>%
  filter(candidate_name == "Donald Trump" | candidate_name == "Joseph R. Biden Jr.") %>%
  ggplot(aes(x = as.Date(modeldate, format = "%m/%d/%y"), y = pct_estimate, color = candidate_name)) + geom_line() + facet_wrap(~state) + labs(title = "Polls by state", caption = "Fig 1.2 State Polls over time for Biden and Trump") + scale_colour_manual(values = c("Joseph R. Biden Jr." = "#123adb", "Donald Trump" = "#E01414")) + xlab("Dates by Month (2020)") + ylab("Percentage estimate of being elected") + theme(plot.title = element_text(hjust = 0.5), , plot.caption = element_text(hjust = 0.5))

p2 <- presidential_poll_averages_2020 %>%
  filter(state == "Florida" | state == "Pennsylvania" | state == "Ohio" | state == "Michigan" | state == "North Carolina" | state == "Arizona" | state == "Wisconsin" |  state == "Iowa") %>%
  filter(candidate_name == "Donald Trump" | candidate_name == "Joseph R. Biden Jr.") %>%
  ggplot(aes(x = as.Date(modeldate, format = "%m/%d/%y"), y = pct_estimate, color = candidate_name)) + geom_line() + facet_wrap(~state) + labs(title = "Polls by Swing State", caption = "Fig 1.3 Swing State Polls over time for Biden and Trump specifically in the swing states (Democratic or Republican") + scale_colour_manual(values = c("Joseph R. Biden Jr." = "#123adb", "Donald Trump" = "#E01414")) + xlab("Dates by Month (2020)") + ylab("Percentage estimate of being elected") + theme(plot.title = element_text(hjust = 0.5), , plot.caption = element_text(hjust = 0.5))
```

```{r senate-race-polls, include = FALSE}
s1 <- senate_polls %>%
  filter(candidate_party == "DEM" | candidate_party == "REP") %>%
  filter(state == "Minnesota" | state == "Michigan" | state == "Arizona" | state == "Colorado" | state == "North Carolina" | state == "Maine" | state == "Iowa" | state == "Montana" | state == "Georgia" | state == "Kansas" | state == "South Carolina" | state == "Alabama" |state == "Alaska" |state == "Texas") %>%
  ggplot(aes(x = as.Date(end_date, format = "%m/%d/%y"), y = pct, color = candidate_party)) + geom_line() + facet_wrap(~race_id) + labs(title = "Polls by closer senate races", caption="Fig 1.4 Polls by closer senate races") + scale_colour_manual(values = c("DEM" = "#123adb", "REP" = "#E01414")) + xlab("Dates by Year") + ylab("Percentage estimate of being elected") + theme(plot.title = element_text(hjust = 0.5), , plot.caption = element_text(hjust = 0.5))
```

```{r nc-senate-race, include = FALSE}
NC_senate <- senate_polls %>%
  filter(state == "North Carolina") %>%
  filter(candidate_party == "DEM" | candidate_party == "REP")

n0 <- NC_senate %>%
  ggplot(aes(x = as.Date(end_date, format = "%m/%d/%y"), y = pct, color = as.factor(candidate_party))) + geom_point() + scale_colour_manual(values = c("DEM" = "#123adb", "REP" = "#E01414")) + xlab("Dates by Poll") + ylab("Percentage estimate of being elected") + theme(plot.title = element_text(hjust = 0.5), , plot.caption = element_text(hjust = 0.5)) + labs(title = "Polls for Individual Senators", caption="Fig 1.5 Polls for individual Senate races labelled by part")
```

By considering the presidential polls data, as seen in Fig. 1, we can observe how the probabilities of being elected for both candidates change over time. We see that Biden has consistently had higher probabilities of being elected than Trump since April 2020, while both candidates experience similar degrees of increase in percentage during their 'Convention Bounce'. Biden appears to consistently have a mean percentage of being elected around 50% and up, and has had a recent surge during October. On the contrary, Trump's percentage estimates have largely been below 45% with a significant drop towards October. From the exploratory data analysis on national polls we can already see that Biden is projected to have an advantage over President Trump.

```{r, echo=FALSE, fig.height=3, fig.width=8}
p0
```
However, this does not tell the full picture, as the United States Presidential Elections adopt an Electoral College system, which sometimes can allow a candidate to become President if that candidate did not receive the popular vote nationally, but secured support in key states that contain a large number of electoral votes. These states have a larger influence on the course of the elections and therefore are highly contested between the two candidates. Figure 1.2 shows the polls for both candidates by state over time, revealing which candidates have advantages over the other in certain states and which states require more attention in order to gain the people's support. Fig 1.3 shows the polls in swing states- States that have relatively equal support for either party and therefore can heavily influence the outcome of the election. For the majority of swing states, Biden similarly is favored statistically to be elected, with the exception of Iowa and Ohio.

```{r, echo=FALSE, fig.width = 13, fig.height = 4}
gridExtra::grid.arrange(p1,p2, ncol=2)
```

For senate data, we look at the senate races and their probabilities for being elected (Democrat or Republican). Over the years, we can observe that there are many close senate races as seen in Fig 1.4. In Fig 1.5, we can also see the percentages for being elected into the senate for individual candidates based on their party affiliation. We can observe that overall Democratic candidates tend to have high percentages for being elected into the senate over Republican candidates, and this distinction becomes more prominent closer to the election date.

```{r, echo=FALSE, fig.width = 13, fig.height = 4}
gridExtra::grid.arrange(s1,n0, ncol=2)
```


## Electoral College Model

The Linzer model is a Bayesian forecast model that specifies how preferences evolve over time and how events are noisy measurements of the underlying preferences.

<!-- Each poll $k$ reports $y_k$, the number of respondents voting Democratic and $n_k$, the total number of respondents voting Democratic and or Republican. $i[k]$ indexes the state, and j[k] is the date in terms of days before the election. Polls from at most J days before the election day, day 1, are used. --> 

The purpose of this model is to predict the outcome of the presidential election by looking at electoral college votes. The probability of Trump winning is calculated by looking at the percentage of times in our 1500 simulations Trump gets 270 or more electoral college votes. In modeling the overall outcome of the presidential election, this model also predicts how each state's electoral college vote will go. Each state's electoral college outcome is modeled by looking at polling data from FiveThirtyEight for that state in order to predict what percent of the popular vote both Trump and Biden receive. Whichever candidate receives a larger percentage of the popular vote receives all of the electoral votes for that state. In reality, Maine and Nebraska can have split electoral college votes instead of the all-or-nothing approach other states take, but we chose to also model these states as all-or-nothing for simplicity sake due to the nature of the polling data that was collected. 

## US Senate Model

Similar to our electoral college model, this model looks at senate race polling data from fivethirtyeight in order to predict the outcome of all current US senate races. The data was filtered to only include general election polling data, so in other words all jungle primary or runoff election polls were removed. Additionally, the data was filtered to only include polls less than a year out from the election. After filtering, we were left with data for all states where senate elections were being held except for Arkansas, Rhode Island, South Dakota, Louisiana, and the second Georgia Race. However, most of these races were predicted to be blowout races, with Arkansas, South Dakota, and Louisiana deemed as safely Republican and Rhode Island deemed safe Democrat. Georgia was the only race we were missing data for that seemed close, but we chose to use the Georgia predictions generated from the other Georgia race we did have data on, since senators are elected by the whole state and it is likely that the same people are voting for both senators. Lastly, polling data for third-parties was filtered out, and the remaining percentages were standardized. In other words, we took the final Democrat and Republican share for each poll, and created a final variable equal to Republican share divided by the total share occupied by Republican and Democrat percentages, to figure out what percentage of the two-party share Republicans were expected to win. Since this is the case, we counted these states as a corresponding Republican or Democratic win in each of our simulations. After making predictions for each individual race, we aggregate the results and look at the percentage of times where Republicans win more than 21 seats, where 21 is the number of seats Republicans need to win in order to have a 50/50 Republican/Democrat split in the senate. 

## North Carolina Senate Model

The North Carolina Senate Model we constructed is a multi-level model. We include a random effect for each county in North Carolina, and the response variable we used is the percentage of registered Republicans in 2018. We chose to use the year 2018 here since this was the year we had most recent data for. Additional predictors are North Carolina Census variables aggregated at the county level, including the percentage of people who live 15 minutes away from where they were, the percentage of people who are foreign-born, the percentage of single parents, the percentage of people who have at least some college education, the percentage of people living below the poverty line, the average rent of a two-bedroom apartment in the county, the average annual job growth from 2004-2013, and then the share of the population that is white, black, asian, and hispanic. All of these variables are taken from the 2010 Census, with the exception of annual average job growth and the rent of a two-bedroom apartment, which was measured in 2015. After the model was used to calculate the percentage of Republicans per county, this data was aggregated and weighted using the total number of people that voted in the 2016 election to come up with a final estimate of the percentage of people who would vote for Republican Thom Tillis. 

## North Carolina House Model

The North Carolina House Model is almost identical to our senate model. We constructed a multi-level model with a random effect for each county in North Carolina, and the response variable we used is the percentage of registered Republicans in 2018. We chose to use the year 2018 here since this was the year we had most recent data for. Additional predictors are North Carolina Census variables aggregated at the county level, including the percentage of people who live 15 minutes away from where they work, the percentage of people who are foreign-born, the percentage of single parents, the percentage of people who have at least some college education, the percentage of people living below the poverty line, the average rent of a two-bedroom apartment in the county, the average annual job growth from 2004-2013, and then the share of the population that is white, black, asian, and hispanic. All of these variables are taken from the 2010 Census, with the exception of annual average job growth and the rent of a two-bedroom apartment, which was measured in 2015. Additionally, we included a  categorical variable which says what party the incumbent belongs to in a particular district. All of the incumbents were Republican or Democrat with the exception of District 11, which had a vacant seat. After the model was used to calculate the percentage of Republicans per county, this data was aggregated and weighted using the total number of people that voted in the 2016 election to come up with a final estimate of the percentage of people who voted Republican in each district. For districts that were split between counties, we divided said counties in half and assigned half of the population to one district and half to the other. We attempted to come up with a better division than this arbitrary half/half split, but we were unable to collect data telling us which zip codes, Census tracts, or other smaller regions belonged to which Congressional district. 

# Results

## Electoral College Model Results

Our model predicts that Trump has a 0% chance of winning. This number seems very low, but we think this is primarily due to the fact that more recent polls are weighted more, and in the most recent polls Biden edges out Trump in many key states. The state predicted to have the highest share of Trump voters is West Virginia, where Trump is predicted to have 65.5% of the two-party share vote, with 95% credible interval (61.7%, 68.4%). The region predicted to have the lowest share of Trump voters is Washington D.C., and our model predicts that Trump will only get 8.9% of the two-party share vote, with 95% credible interval (2.9%, 16.9%). 

### Electoral College Model Validation

For model validation, we plot traceplots for all the beta coefficients. From the traceplots, we can observe that there is randomness across iterations, signifying that convergence has been reached with 1500 iterations. Modifying our initial burn-in rate (250, 500,1000) did not seem to affect model convergence, and thus decided to stick to the original burn-in rate of 500. We also tried different quantities of iterations to see if it would improve the model. We concluded that 1500 simulations produced Rhat values close to 1, signifying that the chains have mixed well.  Similar good results are shown in the lag-1 scatterplots where there seems to be a lot of randomness which means that the model sampler is sampling the entire space in an uncorrelated manner. The ACF plots show little correlation between new samples of beta with previous samples which is also desirable. To see these plots please refer to the appendix.

On top of standard model validation tools, we also performed out-of sample validation by implementing the same model on 2016 data to predict the results of the Clinton-Trump When validating on 2016 election data, we predicted that Clinton had a 87.1% chance of winning. Clinton didn't end up winning the election, however many election prediction models forecasted that she would have a landslide victory. Thus, our model is seemingly consistent with what experts were predicting, which is another aspect of good model fit for the study. 

## US Senate Model Results

We predict that the Republicans have a 0.2% chance of keeping control of the senate. The Republican party wins between 10 and 18 seats most of the time in our simulations, which is shy of the 22 seats needed to win a majority. 

### US Senate Model Validation

Traceplots for this model indicate that convergence was also reached for this model. Additionally, lag-1 scatterplots and autocorrelation plots show that there is no need to be concerned about non-random data or correlations. All of our Rhat values are close to 1, again indicating that the chains have mixed well. 

When using our model to predict the chance of Republicans controlling the senate after the 2018 midterm elections, we get a probability of 71.4%. This estimate seems to be close to what many other well-known political models forecasted, and the Republicans did indeed keep control of the senate after this election. 

## North Carolina Senate Model Results

We predict that Republican Thom Tillis will win 45.6% of the two-party vote-share, and we are 95% confident that this prediction will fall between 40.2% and 50.9%. Since our interval contains 50%, we can not be sure that he will lose the race to Cal Cunningham. 

### North Carolina Senate Model Validation

The residual plots for this model show a random scatter around zero, and the qq plot of residuals shows that they are also approximately normally distributed. 

However, when using the 2016 election as an out-of-sample validation, we predict that the Republican candidate would win 45.6% of the popular vote, with a 95% prediction interval from 40.4% to 50.7%. However, in reality, Republican candidate Richard Burr won the race with 51.1% of the popular vote, and Democratic candidate Deborah K. Ross fell with only 45.4% of the vote [[4]][Bibliography]. This meant that he won 53.0% of the two-party share vote. Thus, our model doesn't hold up perfectly in this out of sample validation. 

For additional sensitivity analysis, we can compare our senate estimates from this model to the ones that we used to factor into our US Senate model. In the Linzer model, North Carolina was predicted to have a 47.9% chance of going Republican, with interval 46.0% to 50.0%. This interval is contained within the interval we calculated from our NC Senate model, indicating that the two model predictions converge, albeit the variance is higher for the NC Senate model. 

## North Carolina House Model Results

We predict that the Republican running in District 1 will receive 29.7% of the two-party share (24.7%, 34.6%), and 40.4% in District 2 (33.1%, 48.3%). In District 3, we expect them to win 49.4% of the two-party share (43.6%, 55.2%), 30.4% in District 4 (23.4%, 38.0%), and 59.1% in District 5 (54.8%, 63.3%). For District 6, our prediction is 40.0% (35.4%, 45.1%), followed by 52.2% in District 7 (47.3%, 57.1%), and 40.6% in District 8 (42.6%, 51.9%). In District 9, we expect the Republican to win 40.6% of the two-party share (34.1%, 47.2%) and 60.8% in District 10 (57.7%, 64.8%). Finally, in District 11, we expect this to be a 49.8% Republican share (45.4%, 54.2%), 0% Republican share in District 12, and a 60.6% Republican share in District 13 (57.0%, 64.1%). District 12 is 0% because the Democrat is running unopposed, and there appears to be no write-in campaign. Districts 3, 7, 8, and 11 appear to be the ones without clear winners, as their prediction intervals all contain 50%.

### North Carolina House Model Validation

Again, the residual plots for this model show a random scatter around zero, and the qq plot of residuals shows that they are also approximately normally distributed. 

For the 2016 Congressional elections, our model predicted District 1 would receive 29.4% of the vote (24.7%, 34.0%), District 2 would receive 42.7% (35.4%, 50.1%), District 3 would receive 48.3% (42.8%, 53.9%), District 4 would receive 32.7% (25.7%, 40.0%), District 5 would receive 57.9% (53.7%, 62.2%), District 6 would receive 39.9% (35.2%, 44.6%), District 7 would receive 51.6% (46.9%, 56.1%), District 8 would receive 46.9% (42.4%, 51.3%), District 9 would receive 41.1% (34.8%, 47.5%), District 10 would receive 59.3% (55.4%, 63.1%), District 11 would receive 50.4% (46.0%, 54.5%), District 12 would receive 36.9% (30.5%, 43.5%), and finally District 13 would receive 58.9% (55.5%, 62.4%). In reality, Republicans won Districts 2, 3, 5, 6, 7, 8, 9, 10, 11, and 13, while Democrats won Districts 1, 4, and 12 [5]. We would have predicted Democrat wins in Districts 2, 3, 6, 8, 9 where this did not actually happen. Part of the reason for this is that North Carolina's Congressional Districts were re-drawn after a gerrymandering lawsuit, so 2020 is the first election where these new districts will be used. Since our model groups districts according to the new lines, it makes sense that our model wouldn't have great predictive power on old data. 

### Who Votes in North Carolina Model

An additional model was created in order to better understand who votes in North Carolina, incorporating information from the North Carolina voter registration database. Ultimately, we modeled the proportion of registered voters who voted in the 2016 and 2018 elections, validating on data from the 2012 and 2014 elections. The predictors included in the voter registration database included race, gender, ethnicity, age group, county, party affiliation, and whether the election was a presidential or midterm election. 

We implemented a binomial mixed-effects model modeling the proportion of registered voter turnout using the aforementioned predictors as fixed effects, as well as random effects on the same predictors as well as an intercept to quantify heterogeneity across congressional districts. Using this model, we were able to understand the trends in voter turnout both across North Carolina broadly, and within competitive congressional districts. For more information about the model and analysis of its results, please consult our separate paper on Who Votes in North Carolina.


# Additinal Discussion
## Limitations
One common limitation across all models was the quality of the data. As polling data often has a disproportionate amount of observations for groups and variables, there will be a degree of uncertainty in our predictions as our sample size does not truly reflect the true opinions of people and certain demographics. There can be underrepresented or misrepresented groups of identities that can dramatically affect the effectiveness of the model.

Another prominent limitation in our Linzer models is that is a consequence of the quality of the data was the unrealistic weightage of polls closer to the election. There is a significant increase in influence that recent polls have on the predictions of the linzer model, which is perhaps why our results for the senate and electoral college are near unanimous as the results of the most recent poll before the election would have a heavy influence on the predictions made by the Linzer model. 

# Bibliography
[1] 2020 Senate Election Interactive Map. (n.d.). Retrieved from https://www.270towin.com/2020-senate-election/
[2] 1918 Pandemic (H1N1 virus). (2019, March 20). Retrieved from https://www.cdc.gov/flu/pandemic-resources/1918-pandemic-h1n1.html#:~:text=The 1918 influenza pandemic was,spread worldwide during 1918-1919
[3] 2016 United States Senate election in North Carolina. (2020, July 31). Retrieved from https://en.wikipedia.org/wiki/2016_United_States_Senate_election_in_North_Carolina
[4] 2016 United States House of Representatives elections in North Carolina. (2020, August 16). Retrieved from https://en.wikipedia.org/wiki/2016_United_States_House_of_Representatives_elections_in_North_Carolina


# Appendix A: Models Used

## 1. Who Votes Model

### Model Purpose

This model aims to predict which groups of people in North Carolina are most likely to vote based on demographic characteristics like race, gender, ethnicity, age, and county of residence. This model also factors in election year, and it can determine whether groups were more likely to vote in the 2018 midterm elections or the 2016 election. 

Please consult our Who Votes paper for more details on the model structure and our estimates. 

## 2. Electoral College Model

### Model Purpose

The purpose of this model is to predict the outcome of the 2020 presidential race. This is accomplished by simulating the outcome of electoral college votes for each state based on polling data and then calculating the total number of times where Trump gets 270 or more electoral votes. This percentage is our probability that Trump wins the election. 

### Model Structure

For a given poll $k$ and corresponding state $j$ and days before the election $t$ (based on poll end date), we model the percent Republican support $y_k$ as
$$\begin{aligned}
y_k \sim N(\beta_{j, t}, \sigma^2_{y,j}) \\
\end{aligned}$$. 
For any $j$ and any $t>1$, we have
$$\begin{aligned}
\beta_{j, t} \sim N(\beta_{j, t-1}, \sigma^2_{\beta,j}) \\
\sigma^2_{y,j} \sim IG(\nu_y, \nu_y * \tau_y) \\
\sigma^2_{\beta,j} \sim IG(\nu_\beta, \nu_\beta * \tau_\beta) \\
\end{aligned}$$
and for any $j$ and $t=1$, we have
$$\begin{aligned}
\beta_{j, 1} \sim N(\mu_0, \sigma^2_0)
\end{aligned}$$.
We only consider polls ending 200 days or less before the election. We include polls from all 50 states.

The Republican presidential candidate wins the electoral college for state $j$ if $w_j := \beta_{j,1} > 0.5$. The same candidate wins the election if 
$$\sum_{j=1}^{50} w_j ec_j \geq 270$$, where $ec_j$ is the number of electoral votes for state $j$.

### Estimates From Model

```{r, echo = FALSE}

pres <- read.csv(file = "data/president_polls.csv") 

pres <- pres %>% 
  mutate(days_to_election = as.Date(election_date, format="%m/%d/%y")-
                  as.Date(start_date, format="%m/%d/%y"))%>%
  filter(candidate_name == "Donald Trump" | candidate_name == "Joseph R. Biden Jr.")%>%
  mutate(days_to_election = as.numeric(days_to_election)) %>%
  filter(days_to_election <= 200)%>%
  filter(question_id != 123584 & question_id != 124133 & question_id != 124134 & question_id != 127451 & question_id != 131614 & question_id != 131615 & question_id != 133072)

pres %>%
  group_by(question_id) %>%
  count() %>%
  arrange(n)

polls_trump <- pres %>%
  filter(candidate_party=="REP") 
r_pct = polls_trump$pct

polls_biden <- pres %>%
  filter(candidate_party == "DEM")
d_pct = polls_biden$pct

polls_trump$rep_pct = 100*r_pct/(r_pct + d_pct)

```


```{r data_list,eval=TRUE, echo = FALSE}
states <- polls_trump$state %>% unique
y <- polls_trump$rep_pct
r <- match(polls_trump$state,states)
t <- polls_trump$days_to_election + 1 #WHY PLUS ONE?
N_polls <- y %>% length
N_states <- states %>% length
N_days <- t %>% max
jags_data_trump <- list(y=y,t=t,r=r,
                  N_polls=N_polls,N_states=N_states,N_days=N_days)

```

```{r, echo = FALSE}
model <- function(){
  for(k in 1:N_polls){
    y[k] ~ dnorm(p[k],1/sigma2_y[r[k]]) #note no longer binomial
    p[k] = beta[r[k],t[k]] 
  }
  for(j in 2:N_days){
    for(i in 1:N_states){
      beta[i,j] ~ dnorm(beta[i,j-1],pow(sigma2_beta[i],-1))
    }
  }
  
  #EXERCISE: add hierarhciacl prior for sigma2_beta and sigma2_y, i.e. sigma2_beta[j] all come from a common distribution 
  for(j in 1:N_states){
      sigma2_y[j] = 1/sigma2_y_inv[j]
      sigma2_y_inv[j] ~ dgamma(nu_y,nu_y*tau_y) 
      
      sigma2_beta[j] = 1/sigma2_beta_inv[j]
      sigma2_beta_inv[j] ~ dgamma(nu_beta,nu_beta*tau_beta) 
      
      beta[j,1] ~ dnorm(mu0,pow(sigma2_0,-1))
  }
  nu_y ~ dunif(0,100)
  tau_y ~ dunif(0,100)
  
  nu_beta ~ dunif(0,100)
  tau_beta ~ dunif(0,100)
  
  mu0 ~ dnorm(50,pow(7.5,-2))
  sigma2_0 = 1/sigma2_0_inv
  sigma2_0_inv ~ dgamma(.5,.5)
}
```

```{r run_model,eval=TRUE, echo = FALSE}
#be sure to add your added parameters to parameters.to.save
set.seed(13)
jags_sims_trump <- jags(data = jags_data_trump,
                  model.file = model,
                  parameters.to.save = c("beta[1,1]",
                                                                          "beta[2,1]",
                                                                          "beta[3,1]",
                                                                          "beta[4,1]",
                                                                          "beta[5,1]",
                                                                          "beta[6,1]",
                                                                          "beta[7,1]",
                                                                          "beta[8,1]",
                                                                          "beta[9,1]",
                                                                          "beta[10,1]",
                                                                          "beta[11,1]",
                                                                          "beta[12,1]",
                                                                          "beta[13,1]",
                                                                          "beta[14,1]",
                                                                          "beta[15,1]",
                                                                          "beta[16,1]",
                                                                          "beta[17,1]",
                                                                          "beta[18,1]",
                                                                          "beta[19,1]",
                                                                          "beta[20,1]",
                                                                          "beta[21,1]",
                                                                          "beta[22,1]",
                                                                          "beta[23,1]",
                                                                          "beta[24,1]",
                                                                          "beta[25,1]",
                                                                          "beta[26,1]",
                                                                          "beta[27,1]",
                                                                          "beta[28,1]",
                                                                          "beta[29,1]",
                                                                          "beta[30,1]",
                                                                          "beta[31,1]",
                                                                          "beta[32,1]",
                                                                          "beta[33,1]",
                                                                          "beta[34,1]",
                                                                          "beta[35,1]",
                                                                          "beta[36,1]",
                                                                          "beta[37,1]",
                                                                          "beta[38,1]",
                                                                          "beta[39,1]",
                                                                          "beta[40,1]",
                                                                          "beta[41,1]",
                                                                          "beta[42,1]",
                                                                          "beta[43,1]",
                                                                          "beta[44,1]",
                                                                          "beta[45,1]",
                                                                          "beta[46,1]",
                                                                          "beta[47,1]",
                                                                          "beta[48,1]",
                                                                          "beta[49,1]",
                                                                          "beta[50,1]",
                                         "beta[51,1]",
                                         "beta[52,1]",
                                         "beta[53,1]",
                                         "beta[54,1]",
                                         "beta[55,1]",
                                         "beta[56,1]"),
                  n.iter = 1000)
```


```{r, echo = FALSE}
jags_r <- jags_sims_trump
b1r <- jags_r$BUGSoutput$sims.array[1:1500]
b10r <- jags_r$BUGSoutput$sims.array[1501:3000]
b11r <- jags_r$BUGSoutput$sims.array[3001:4500]
b12r <- jags_r$BUGSoutput$sims.array[4501:6000]
b13r <- jags_r$BUGSoutput$sims.array[6001:7500]
b14r <- jags_r$BUGSoutput$sims.array[7501:9000]
b15r <- jags_r$BUGSoutput$sims.array[9001:10500]
b16r <- jags_r$BUGSoutput$sims.array[10501:12000]
b17r <- jags_r$BUGSoutput$sims.array[12001:13500]
b18r <- jags_r$BUGSoutput$sims.array[13501:15000]
b19r <- jags_r$BUGSoutput$sims.array[15001:16500]
b2r <- jags_r$BUGSoutput$sims.array[16501:18000]
b20r <- jags_r$BUGSoutput$sims.array[18001:19500]
b21r <- jags_r$BUGSoutput$sims.array[19501:21000]
b22r <- jags_r$BUGSoutput$sims.array[21001:22500]
b23r <- jags_r$BUGSoutput$sims.array[22501:24000]
b24r <- jags_r$BUGSoutput$sims.array[24001:25500]
b25r <- jags_r$BUGSoutput$sims.array[25501:27000]
b26r <- jags_r$BUGSoutput$sims.array[27001:28500]
b27r <- jags_r$BUGSoutput$sims.array[28501:30000]
b28r <- jags_r$BUGSoutput$sims.array[30001:31500]
b29r <- jags_r$BUGSoutput$sims.array[31501:33000]
b3r <- jags_r$BUGSoutput$sims.array[33001:34500]
b30r <- jags_r$BUGSoutput$sims.array[34501:36000]
b31r <- jags_r$BUGSoutput$sims.array[36001:37500]
b32r <- jags_r$BUGSoutput$sims.array[37501:39000]
b33r <- jags_r$BUGSoutput$sims.array[39001:40500]
b34r <- jags_r$BUGSoutput$sims.array[40501:42000]
b35r <- jags_r$BUGSoutput$sims.array[42001:43500]
b36r <- jags_r$BUGSoutput$sims.array[43501:45000]
b37r <- jags_r$BUGSoutput$sims.array[45001:46500]
b38r <- jags_r$BUGSoutput$sims.array[46501:48000]
b39r <- jags_r$BUGSoutput$sims.array[48001:49500]
b4r <- jags_r$BUGSoutput$sims.array[49501:51000]
b40r <- jags_r$BUGSoutput$sims.array[51001:52500]
b41r <- jags_r$BUGSoutput$sims.array[52501:54000]
b42r <- jags_r$BUGSoutput$sims.array[54001:55500]
b43r <- jags_r$BUGSoutput$sims.array[55501:57000]
b44r <- jags_r$BUGSoutput$sims.array[57001:58500]
b45r <- jags_r$BUGSoutput$sims.array[58501:60000]
b46r <- jags_r$BUGSoutput$sims.array[60001:61500]
b47r <- jags_r$BUGSoutput$sims.array[61501:63000]
b48r <- jags_r$BUGSoutput$sims.array[63001:64500]
b49r <- jags_r$BUGSoutput$sims.array[64501:66000]
b5r <- jags_r$BUGSoutput$sims.array[66001:67500]
b50r <- jags_r$BUGSoutput$sims.array[67501:69000]
b51r <- jags_r$BUGSoutput$sims.array[69001:70500]
b52r <- jags_r$BUGSoutput$sims.array[70501:72000]
b53r <- jags_r$BUGSoutput$sims.array[72001:73500]
b54r <- jags_r$BUGSoutput$sims.array[73501:75000]
b55r <- jags_r$BUGSoutput$sims.array[75001:76500]
b56r <- jags_r$BUGSoutput$sims.array[76501:78000]
b6r <- jags_r$BUGSoutput$sims.array[78001:79500]
b7r <- jags_r$BUGSoutput$sims.array[79501:81000]
b8r <- jags_r$BUGSoutput$sims.array[81001:82500]
b9r <- jags_r$BUGSoutput$sims.array[82501:84000]


w1 = ifelse(b1r > 50, 6, 0) #IA
w2 = ifelse(b2r > 50, 20, 0) #PA
w3 = ifelse(b3r > 50, 0, 0) #national
w4 = ifelse(b4r > 50, 11, 0) # AZ
w5 = ifelse(b5r > 50, 16, 0) # GA
w6 = ifelse(b6r > 50, 20, 0) # IL
w7 = ifelse(b7r > 50, 16, 0) # MI
w8 = ifelse(b8r > 50, 10, 0) # MN
w9 = ifelse(b9r > 50, 14, 0) # NJ
w10 = ifelse(b10r > 50, 29, 0) # NY
w11 = ifelse(b11r > 50, 18, 0) # OH
w12 = ifelse(b12r > 50, 10, 0) # WI
w13 = ifelse(b13r > 50, 29, 0) # FL
w14 = ifelse(b14r > 50, 9, 0) # CO
w15 = ifelse(b15r > 50, 55, 0) # CA
w16 = ifelse(b16r > 50, 15, 0) # NC
w17 = ifelse(b17r > 50, 38, 0) # TX
w18 = ifelse(b18r > 50, 13, 0) # VA
w19 = ifelse(b19r > 50, 9, 0) # AL
w20 = ifelse(b20r > 50, 3, 0) # WY
w21 = ifelse(b21r > 50, 5, 0) # WV 
w22 = ifelse(b22r > 50, 12, 0) # WA
w23 = ifelse(b23r > 50, 3, 0) # VT
w24 = ifelse(b24r > 50, 6, 0) # UT
w25 = ifelse(b25r > 50, 11, 0) # TN
w26 = ifelse(b26r > 50, 3, 0) # SD
w27 = ifelse(b27r > 50, 9, 0) # SC
w28 = ifelse(b28r > 50, 4, 0) # RI
w29 = ifelse(b29r > 50, 7, 0) # OR
w30 = ifelse(b30r > 50, 7, 0) # OK
w31 = ifelse(b31r > 50, 6, 0) # NV
w32 = ifelse(b32r > 50, 5, 0) # NM
w33 = ifelse(b33r > 50, 4, 0) # NH
w34 = ifelse(b34r > 50, 5, 0) # NE
w35 = ifelse(b35r > 50, 3, 0) # ND
w36 = ifelse(b36r > 50, 3, 0) # MT
w37 = ifelse(b37r > 50, 6, 0) # MS
w38 = ifelse(b38r > 50, 10, 0) # MO
w39 = ifelse(b39r > 50, 4, 0) # ME
w40 = ifelse(b40r > 50, 10, 0) # MD
w41 = ifelse(b41r > 50, 11, 0) # MA
w42 = ifelse(b42r > 50, 8, 0) # LA
w43 = ifelse(b43r > 50, 8, 0) # KY
w44 = ifelse(b44r > 50, 6, 0) # KS
w45 = ifelse(b45r > 50, 11, 0) # IN
w46 = ifelse(b46r > 50, 4, 0) # ID
w47 = ifelse(b47r > 50, 4, 0) # HI
w48 = ifelse(b48r > 50, 3, 0) # DE
w49 = ifelse(b49r > 50, 3, 0) # DC
w50 = ifelse(b50r > 50, 7, 0) # CT
w51 = ifelse(b51r > 50, 6, 0) # AR
w52 = ifelse(b52r > 50, 3, 0) # AK
w53 = ifelse(b53r > 50, 0, 0) # ME CD-1
w54 = ifelse(b54r > 50, 0, 0) # ME CD-2
w55 = ifelse(b55r > 50, 0, 0) # NE CD-2
w56 = ifelse(b56r > 50, 0, 0) # NE CD-1

r_wins <- data.frame(cbind(w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15, w16, w17, w18, w19, w20, w21, w22, w23, w24, w25, w26, w27, w28, w29, w30, w31,w32,w33,w34,w35,w36,w37,w38,w39,w40,w41,w42,w43,w44,w45,w46,w47,w48,w49,w50,w51,w52,w53,w54,w55,w56))

n = nrow(r_wins)

r_wins$total = rowSums(r_wins)

trump_electoral <- r_wins%>%
  filter(total > 269) %>%
  summarise(perc = n()/nrow(r_wins)) %>%
  pull()

trump_electoral

```

```{r, echo = FALSE}
jags_r$BUGSoutput
```

## 3. US Senate Model

### Model Purpose

This model predicts the probability that the senate will remain in Republican control. This is accomplished by simulating the outcomes of all 35 senate races based on polling data and calculating the total number of times where Republicans win more than 21 of these seats, as 21 is the number of seats where the senate remains in a 50/50 Democrat/Republican split. The percentage of our simulations that have Republicans winning over 21 seats is the probability that they will keep control of the senate.

### Model Structure

This model is identical to that for the electoral college, except only a subset of the states and we consider polls ending 364 days or less before the election. A Republican senator wins their respective election in state $j$ if $\beta_{j,1} > 0.5$. 

### Estimates From Model
```{r, echo = FALSE}

senate_polls <- read.csv(file='data/senate_polls.csv')
senate_polls <- senate_polls %>%
  mutate(days_to_election = as.Date(as.character(election_date), format ="%m/%d/%Y")-as.Date(as.character(start_date), format = "%m/%d/%Y")) %>%
  filter(cycle == 2020) %>%
  filter(stage != "jungle primary") %>%
  filter(stage != "runoff") %>%
  filter(days_to_election <= 365) %>%
  filter(state != "Arkansas") %>%
  filter(candidate_party == "REP" | candidate_party == "DEM")%>%
  mutate(days_to_election = as.numeric(days_to_election))


polls_republican <- senate_polls %>%
  filter(candidate_party=="REP") 
r_pct = polls_republican$pct

polls_not_republican <- senate_polls %>%
  filter(candidate_party == "DEM")
d_pct = polls_not_republican$pct


polls_republican$rep_pct = 100*r_pct/(r_pct + d_pct)
```


```{r, echo = FALSE}
state <- polls_republican$state %>% unique
y <- polls_republican$rep_pct
r <- match(polls_republican$state,state)
t <- polls_republican$days_to_election + 1
N_polls <- y %>% length
N_states <- state %>% length
N_days <- t %>% max
jags_data_republican <- list(y=y,t=t,r=r,
                  N_polls=N_polls,N_states=N_states,N_days=N_days)

```

```{r, echo = FALSE}
model <- function(){
  for(k in 1:N_polls){
    y[k] ~ dnorm(p[k],1/sigma2_y[r[k]]) #note no longer binomial
    p[k] = beta[r[k],t[k]] 
  }
  for(j in 2:N_days){
    for(i in 1:N_states){
      beta[i,j] ~ dnorm(beta[i,j-1],pow(sigma2_beta[i],-1))
    }
  }
  
  #EXERCISE: add hierarhciacl prior for sigma2_beta and sigma2_y, i.e. sigma2_beta[j] all come from a common distribution 
  for(j in 1:N_states){
      sigma2_y[j] = 1/sigma2_y_inv[j]
      sigma2_y_inv[j] ~ dgamma(nu_y,nu_y*tau_y) 
      
      sigma2_beta[j] = 1/sigma2_beta_inv[j]
      sigma2_beta_inv[j] ~ dgamma(nu_beta,nu_beta*tau_beta) 
      
      beta[j,1] ~ dnorm(mu0,pow(sigma2_0,-1))
  }
  nu_y ~ dunif(0,100)
  tau_y ~ dunif(0,100)
  
  nu_beta ~ dunif(0,100)
  tau_beta ~ dunif(0,100)
  
  mu0 ~ dnorm(50,pow(7.5,-2))
  sigma2_0 = 1/sigma2_0_inv
  sigma2_0_inv ~ dgamma(.5,.5)
}
```


```{r, echo = FALSE}
set.seed(1)
jags_r <- jags(data = jags_data_republican,
                  model.file = model,
                  parameters.to.save = c("beta[1,1]", "beta[2,1]", "beta[3,1]", "beta[4,1]", "beta[5,1]", 
                                         "beta[6,1]", "beta[7,1]", "beta[8,1]", "beta[9,1]", "beta[10,1]",
                                         "beta[11,1]", "beta[12,1]", "beta[13,1]", "beta[14,1]", "beta[15,1]",
                                         "beta[16,1]", "beta[17,1]", "beta[18,1]", "beta[19,1]", "beta[20,1]",
                                         "beta[21,1]", "beta[22,1]", "beta[23,1]", "beta[24,1]", "beta[25,1]",
                                         "beta[26,1]", "beta[27,1]", "beta[28,1]", "beta[29,1]", "beta[30,1]"),
                  n.iter = 1000)

b1r <- jags_r$BUGSoutput$sims.array[1:1500]
b10r <- jags_r$BUGSoutput$sims.array[1501:3000]
b11r <- jags_r$BUGSoutput$sims.array[3001:4500]
b12r <- jags_r$BUGSoutput$sims.array[4501:6000]
b13r <- jags_r$BUGSoutput$sims.array[6001:7500]
b14r <- jags_r$BUGSoutput$sims.array[7501:9000]
b15r <- jags_r$BUGSoutput$sims.array[9001:10500]
b16r <- jags_r$BUGSoutput$sims.array[10501:12000]
b17r <- jags_r$BUGSoutput$sims.array[12001:13500]
b18r <- jags_r$BUGSoutput$sims.array[13501:15000]
b19r <- jags_r$BUGSoutput$sims.array[15001:16500]
b2r <- jags_r$BUGSoutput$sims.array[16501:18000]
b20r <- jags_r$BUGSoutput$sims.array[18001:19500]
b21r <- jags_r$BUGSoutput$sims.array[19501:21000]
b22r <- jags_r$BUGSoutput$sims.array[21001:22500]
b23r <- jags_r$BUGSoutput$sims.array[22501:24000]
b24r <- jags_r$BUGSoutput$sims.array[24001:25500]
b25r <- jags_r$BUGSoutput$sims.array[25501:27000]
b26r <- jags_r$BUGSoutput$sims.array[27001:28500]
b27r <- jags_r$BUGSoutput$sims.array[28501:30000]
b28r <- jags_r$BUGSoutput$sims.array[30001:31500]
b29r <- jags_r$BUGSoutput$sims.array[31501:33000]
b3r <- jags_r$BUGSoutput$sims.array[33001:34500]
b30r <- jags_r$BUGSoutput$sims.array[34501:36000]
b4r <- jags_r$BUGSoutput$sims.array[36001:37500]
b5r <- jags_r$BUGSoutput$sims.array[37501:39000]
b6r <- jags_r$BUGSoutput$sims.array[39001:40500]
b7r <- jags_r$BUGSoutput$sims.array[40501:42000]
b8r <- jags_r$BUGSoutput$sims.array[42001:43500]
b9r <- jags_r$BUGSoutput$sims.array[43501:45000]
```

```{r, echo = FALSE}
jags_r$BUGSoutput
```

```{r, echo = FALSE}
w1 = ifelse(b1r > 50, 1, 0)
w2 = ifelse(b2r > 50, 1, 0)
w3 = ifelse(b3r > 50, 1, 0)
w4 = ifelse(b4r > 50, 1, 0)
w5 = ifelse(b5r > 50, 1, 0)
w6 = ifelse(b6r > 50, 1, 0)
w7 = ifelse(b7r > 50, 1, 0)
w8 = ifelse(b8r > 50, 1, 0)
w9 = ifelse(b9r > 50, 1, 0)
w10 = ifelse(b10r > 50, 1, 0)
w11 = ifelse(b11r > 50, 1, 0)
w12 = ifelse(b12r > 50, 1, 0)
w13 = ifelse(b13r > 50, 1, 0)
w14 = ifelse(b14r > 50, 1, 0)
w15 = ifelse(b15r > 50, 1, 0)
w16 = ifelse(b16r > 50, 1, 0)
w17 = ifelse(b17r > 50, 1, 0)
w18 = ifelse(b18r > 50, 1, 0)
w19 = ifelse(b19r > 50, 1, 0)
w20 = ifelse(b20r > 50, 1, 0)
w21 = ifelse(b21r > 50, 1, 0)
w22 = ifelse(b22r > 50, 1, 0)
w23 = ifelse(b23r > 50, 1, 0)
w24 = ifelse(b24r > 50, 1, 0)
w25 = ifelse(b25r > 50, 1, 0)
w26 = ifelse(b26r > 50, 1, 0)
w27 = ifelse(b27r > 50, 1, 0)
w28 = ifelse(b28r > 50, 1, 0)
w29 = ifelse(b29r > 50, 1, 0)
w30 = ifelse(b30r > 50, 1, 0)
w31 = ifelse(b3r > 50, 1, 0)

r_wins <- data.frame(cbind(w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15, w16, w17, w18, w19, w20, w21, w22, w23, w24, w25, w26, w27, w28, w29, w30, w31))

n = nrow(r_wins)

#rowSums(r_wins)
r_wins$total = rowSums(r_wins)

#missing a few states, but these races aren't predicted to be close
#RHODE ISLAND(D) #SOUTH DAKOTA(R) #LOUISIANA(R) # ARKANSAS(R) #double Georgia
# R + 3, need 21 total for split
#18

repub_senate <- r_wins%>%
  filter(total > 18) %>%
  summarise(perc = n()/nrow(r_wins)) %>%
  pull()

repub_senate

#hist(r_wins$total)
```


## 4. North Carolina Senate Model

### Model Purpose

The purpose of this model is to predict the outcome of the North Carolina senate race between Democrat Cal Cunningham and Republican Thom Tillis.
Predictor variables are the same as those in the model above, and similarly, we use the percentage of Republican votes (out of all Democratic and Republic votes in a given county) as our response variable as a proxy for the number of people we expect to vote for Thom Tillis.

### Model Structure
This model is identical to the House model above, except for each $Republican \ Share_{i}$, we do not include predictors based on incumbent party. That is, we have
$$\begin{aligned}
Republican \ Share_{i} = \alpha_{i} + \beta_{travel\ time_i} + \beta_{foreign \ share_i} + \beta_{single \ parent \
 share_i} + \\
 \beta_{fraction \ college_i} + \beta_{poor \ share_i} + \beta_{two \ bed \ rent_i} + \beta_{job \ growth_i} + \\ 
 \beta_{share \ white_i} + \beta_{share \ black_i} + \beta_{share \ hispanic_i} + \beta_{share \ asian_i} \\ 
where \ \alpha_{i} \sim N(\gamma_0, \tau^2)  \\ 
and \ \epsilon_{i} \sim N(0, \sigma^2)
\end{aligned}$$

We calculated the overall Republican share for all districts simply as $$Tillis = \sum_{j=1}^{13} Republican \ District_{j}$$. Tillis was considered to win the election if $Tillis > 0.5$.

### Estimates From Model
```{r, echo = F}
# linear mixed model with random effect for county
M3 <- lmer(Republican.percentage ~ traveltime15_2010 + foreign_share2010 + singleparent_share2010 +  incumbent_party + frac_coll_plus2010 + poor_share2010 + rent_twobed2015 + ann_avg_job_growth_2004_2013 + share_white2010 + share_black2010 + share_hisp2010 + share_asian2010 +  (1|county), data = rep2018, control = lmerControl(optimizer ="Nelder_Mead"))

PI <- predictInterval(merMod = M3, newdata = full_counties,
                        level = 0.95, n.sims = 1000,
                        stat = "median", type="linear.prediction",
                        include.resid.var = TRUE)

# account for counties split into 2 districts
modified_counties <- full_counties %>%
  mutate(Totals = as.numeric(gsub(",","",Totals))) %>%
  mutate(voters = case_when(split == "y" ~ Totals/2,
                            TRUE ~ Totals))

modified_counties$fit = PI$fit
modified_counties$lower = PI$lwr
modified_counties$upper = PI$upr

# weight county vote share by number of people who voted in 2016 election
modified_counties %>%
  group_by(district) %>%
  summarise(dist_share_rep = sum(fit*voters)/sum(voters),
            dist_lwr_rep = sum(lower*voters)/sum(voters),
            dist_upr_rep = sum(upper*voters)/sum(voters))
```

## 5. North Carolina House Model

### Model Purpose

The purpose of this model is to predict the outcome of the 13 races in North Carolina that will determine who gets elected to the US House of Representatives. In order to achieve this prediction, we used the percentage of registered Republicans in a given county as our response variable as a proxy for the number of people we expect to vote Republican, and predictor variables include economic, race, and education data from the North Carolina Census. 

### Model Structure
We used a linear model with a random effect for county.

$$\begin{aligned}
Republican \ Share_{i} = \alpha_{i} + \beta_{travel\ time_i} + \beta_{foreign \ share_i} + \beta_{single \ parent \
 share_i} + \\
 \beta_{fraction \ college_i} + \beta_{poor \ share_i} + \beta_{two \ bed \ rent_i} + \beta_{job \ growth_i} + \\ 
 \beta_{share \ white_i} + \beta_{share \ black_i} + \beta_{share \ hispanic_i} + \beta_{share \ asian_i} + \\ \beta_{incumbent \ party \ Republican_i} + \beta_{incumbent \ party \ None_i} +\epsilon_{i} \\ 
where \ \alpha_{i} \sim N(\gamma_0, \tau^2)  \\ 
and \ \epsilon_{i} \sim N(0, \sigma^2)
\end{aligned}$$

where $i$ represents a given county. The republican share for a district $j$ is then calculated as 
$$Republican \ District_{j} = \sum_{i \in counties_j} t^*_i $$
where $counties_j$ is the set of counties in district $j$, and $t^*_i = \frac{t_i}{2 I(split_i)}$, where $t_i$ is the total number of voters in county $i$, $I$ is the indicator function, and $split_i$ is a boolean of whether county $i$ is divided into two districts. Each split county was examined individually and looked geographically split in half for each district, so dividing the total by 2 is a reasonable approximation we can make with our given data. The Republican was considered to win the district if $Republican \ District_{j} > 0.5$.

### Estimates From Model
```{r, echo = FALSE}
# estimate percentages across whole state

M4 <- lmer(Republican.percentage ~ traveltime15_2010 + foreign_share2010 + singleparent_share2010 + frac_coll_plus2010 + poor_share2010 + rent_twobed2015 + ann_avg_job_growth_2004_2013 + share_white2010 + share_black2010 + share_hisp2010 + share_asian2010 +  (1|county), data = rep2018, control = lmerControl(optimizer ="Nelder_Mead"))

PI <- predictInterval(merMod = M4, newdata = full_counties,
                        level = 0.95, n.sims = 1000,
                        stat = "median", type="linear.prediction",
                        include.resid.var = TRUE)

# account for counties split into 2 districts
modified_counties <- full_counties %>%
  mutate(Totals = as.numeric(gsub(",","",Totals))) %>%
  mutate(voters = case_when(split == "y" ~ Totals/2,
                            TRUE ~ Totals))

modified_counties$fit = PI$fit
modified_counties$lower = PI$lwr
modified_counties$upper = PI$upr

# weight county vote share by number of people who voted in 2016 election

modified_counties %>%
  summarise(dist_share_rep = sum(fit*voters)/sum(voters),
            dist_lwr_rep = sum(lower*voters)/sum(voters),
            dist_upr_rep = sum(upper*voters)/sum(voters))

```

# Appendix B: Data Sources 
NC Voter Data: 
Used in North Carolina House Model and Who Votes in North Carolina Model
Variables used: % of people registered as Republicans in 2016 and 2018
Used in Who Votes model???
https://dl.ncsbe.gov/?prefix=data/

Mapping for Who Votes:
```{r fig.align="center", echo=FALSE, warning=FALSE}
features_tbl <- data.frame(
  Metric = c(rep("n", 1),
             rep("race", 2),
             rep("gender",1),
             rep("ethnicity",1),
             rep("age group",1),
             rep("county",1),
             rep("presidential",1),
             rep("party", 1)),
  
  Groups = linebreak(c("Number of voters",
                       "A = Asian, B = Black or African American, I = American Indian or Native American, ", 
                       "M = Two or more races , O = Other , U = Undesignated, W = White", 
                       "M = Male, F = Female, U = Preferred not to respond", 
                        "HL = Hispanic or Latino, NL = Non-hispanic/Non-Latino, UN = Undesignated",
                       "Age groups of 18-24, 25-44, 45-64, 65+",
                       "North Carolina's 100 counties",
                       "0 = Midterm election, 1 = Presidential election",
                       "DEM = Democrat, REP = Republican, CST = Constitutional, GRN = Green, LIB = Libertarian, UNA = Unaffiliated")
  )
)
features_tbl %>% 
  kable(escape=F,   booktabs = T, align = "c",
        caption = "Table 1.1 Description Table of Data set variables",) %>%
  kable_styling(latex_options = c("hold_position")) %>% 
  collapse_rows(columns = 1, latex_hline = "major") %>% 
  row_spec(0, bold = TRUE) #%>% 
#column_spec(column = c(2), latex_column_spec = "c")
```


Census Data: Neighborhood characteristics by county in North Carolina 
Used in North Carolina House and Senate Models
Variables used: percentage of people who live 15 minutes away from where they work in a given county (2010),  percentage of people who are foreign-born in a given county (2010), the percentage of single parents in a given county (2010), the percentage of people who have at least some college education in a given county (2010), the percentage of people living below the poverty line in a given county (2010), the average rent of a two-bedroom apartment in the county (2015), the average annual job growth from 2004-2013, the share of the population that is white, black, asian, and hispanic (2010)
https://opportunityinsights.org/data/?geographic_level=0&topic=0&paper_id=0#resource-listing

Ballotpedia: 
Used in North Carolina House Model
Variables used: Incumbent Party for NC Congressional Races
https://ballotpedia.org/United_States_House_of_Representatives_elections_in_North_Carolina,_2020

North Carolina County Data: 
Used in North Carolina House and Senate Models
Variables used: What district all the counties in North Carolina are a part of
http://speakermoore.com/new-n-c-congressional-districts-approved-state-house-representatives/

North Carolina 2016 Election Data: 
Used in North Carolina House and Senate Models
Variables used: Total number of voters by county in 2016 presidential election
https://en.wikipedia.org/wiki/2016_United_States_presidential_election_in_North_Carolina#:~:text=The%202016%20United%20States%20presidential,of%20the%202016%20general%20election.

Fivethirtyeight senate polling data
Used for model building (2020) and validation (2018) in US Senate Model
Variables used: days until election, polling state, candidate party, percentage of support in poll

Fivethirtyeight presidential polling data
Used for model building in Electoral College Model
Variables used: days until election, polling state, candidate party, percentage of support in poll

2016 Economist Presidential Polling Data
Used as validation for the Electoral College Model
Variables used: days until election, polling state, candidate party, percentage of support in poll

# Appendix C: Diagnostic Plots 

## Traceplots, Lag-1 Scatterplots, and ACF Plots for Presidential and US Senate Models

### Presidential Model
    
```{r, echo = F, include = F}
# run traceplots
parameters = c(names(data.frame(jags_sims_trump$BUGSoutput$sims.matrix)))[1:56]

res = data.frame(jags_sims_trump$BUGSoutput$sims.matrix)[,parameters]

tps <- function(var){
  ggplot(res, aes_(y=as.name(var), x=seq(1,nrow(res)))) +
    geom_line() +
    labs(title=paste("Traceplot of ", as.name(var)),
         x ="Iterations", y = as.name(var))
}
lapply(names(res), tps)

```

```{r, echo = FALSE, message=FALSE, warning=FALSE, include = F}
# run lag-1 scatterplots
library(ggplot2)
res_lag1 = lapply(seq(1:length(res)), function(i) {
  lres = lag(res[,i],1)
  plot(y=res[,i], x= lres, 
       xlab = paste0(colnames(res)[i], "-1"),
       ylab = paste0(colnames(res)[i]),
       main = paste("Lag-1 Scatter Plot of", colnames(res)[i]))
})
```


```{r, echo = F, message=FALSE, warning=FALSE, include = F}
# run acf plots
lapply(seq(1,length(res)), function(i) { 
  acf(res[,i], xlab = "Lag", ylab = "ACF", 
            main = paste("ACF Plot of ", colnames(res)[i]))
})
```

### US Senate Model
```{r, echo = F, include = F}
# run traceplots
parameters = c(names(data.frame(jags_r$BUGSoutput$sims.matrix)))[1:31]

res = data.frame(jags_r$BUGSoutput$sims.matrix)[,parameters]

tps <- function(var){
  ggplot(res, aes_(y=as.name(var), x=seq(1,nrow(res)))) +
    geom_line() +
    labs(title=paste("Traceplot of ", as.name(var)),
         x ="Iterations", y = as.name(var))
}
lapply(names(res), tps)
```

```{r, echo = FALSE, message=FALSE, warning=FALSE, include = F}
# run lag-1 scatterplots
library(ggplot2)
res_lag1 = lapply(seq(1:length(res)), function(i) {
  lres = lag(res[,i],1)
  plot(y=res[,i], x= lres, 
       xlab = paste0(colnames(res)[i], "-1"),
       ylab = paste0(colnames(res)[i]),
       main = paste("Lag-1 Scatter Plot of", colnames(res)[i]))
})
```

```{r, echo = F, message=FALSE, warning=FALSE, include = F}
# run acf plots
lapply(seq(1,length(res)), function(i) { 
  acf(res[,i], xlab = "Lag", ylab = "ACF", 
            main = paste("ACF Plot of ", colnames(res)[i]))
})
```

## Residual Plots for NC House and Senate Models
```{r, echo = F, include = F}
plot(M4)
qqnorm(residuals(M4))
```

```{r, echo = F, include - F}
plot(M3)
qqnorm(residuals(M3))
```

# Appendix D: Out-of-Sample Validation

## Electoral College - 2016 Election
```{r, echo = FALSE, include = F}
set.seed(2016)
polls <- read_csv("data/2016_Economist_Polls.csv") %>% 
  filter(population %in% c("Likely Voters","Registered Voters"),question.iteration == 1) %>% #remove duplicate questions
  mutate(days_to_election = ifelse(end.date == "11/7/16", 1, ifelse(end.date == "11/6/16",2, ifelse(end.date == "11/5/16",3,101))),
         state = ifelse(state == "--","US",state),
         y = clinton/(clinton + trump)*100)

polls <- polls %>%
  filter(days_to_election <= 100)

states <- polls$state %>% unique
y <- polls$y
r <- match(polls$state,states)
t <- polls$days_to_election + 1 #WHY PLUS ONE?
N_polls <- y %>% length
N_states <- states %>% length
N_days <- t %>% max
jags_data <- list(y=y,t=t,r=r,
                  N_polls=N_polls,N_states=N_states,N_days=N_days)

model <- function(){
  for(k in 1:N_polls){
    y[k] ~ dnorm(p[k],1/sigma2_y[r[k]]) #note no longer binomial
    p[k] = beta[r[k],t[k]] 
  }
  for(j in 2:N_days){
    for(i in 1:N_states){
      beta[i,j] ~ dnorm(beta[i,j-1],pow(sigma2_beta[i],-1))
    }
  }
  
  #EXERCISE: add hierarhciacl prior for sigma2_beta and sigma2_y, i.e. sigma2_beta[j] all come from a common distribution 
  for(j in 1:N_states){
      sigma2_y[j] = 1/sigma2_y_inv[j]
      sigma2_y_inv[j] ~ dgamma(nu_y,nu_y*tau_y) 
      
      sigma2_beta[j] = 1/sigma2_beta_inv[j]
      sigma2_beta_inv[j] ~ dgamma(nu_beta,nu_beta*tau_beta) 
      
      beta[j,1] ~ dnorm(mu0,pow(sigma2_0,-1))
  }
  nu_y ~ dunif(0,100)
  tau_y ~ dunif(0,100)
  
  nu_beta ~ dunif(0,100)
  tau_beta ~ dunif(0,100)
  
  mu0 ~ dnorm(50,pow(7.5,-2))
  sigma2_0 = 1/sigma2_0_inv
  sigma2_0_inv ~ dgamma(.5,.5)
}

jags_r <- jags(data = jags_data,model.file = model,parameters.to.save = c("beta[1,1]",
                                                                          "beta[2,1]",
                                                                          "beta[3,1]",
                                                                          "beta[4,1]",
                                                                          "beta[5,1]",
                                                                          "beta[6,1]",
                                                                          "beta[7,1]",
                                                                          "beta[8,1]",
                                                                          "beta[9,1]",
                                                                          "beta[10,1]",
                                                                          "beta[11,1]",
                                                                          "beta[12,1]",
                                                                          "beta[13,1]",
                                                                          "beta[14,1]",
                                                                          "beta[15,1]",
                                                                          "beta[16,1]",
                                                                          "beta[17,1]",
                                                                          "beta[18,1]",
                                                                          "beta[19,1]",
                                                                          "beta[20,1]",
                                                                          "beta[21,1]",
                                                                          "beta[22,1]",
                                                                          "beta[23,1]",
                                                                          "beta[24,1]",
                                                                          "beta[25,1]",
                                                                          "beta[26,1]",
                                                                          "beta[27,1]",
                                                                          "beta[28,1]",
                                                                          "beta[29,1]",
                                                                          "beta[30,1]",
                                                                          "beta[31,1]",
                                                                          "beta[32,1]",
                                                                          "beta[33,1]",
                                                                          "beta[34,1]",
                                                                          "beta[35,1]",
                                                                          "beta[36,1]",
                                                                          "beta[37,1]",
                                                                          "beta[38,1]",
                                                                          "beta[39,1]",
                                                                          "beta[40,1]",
                                                                          "beta[41,1]",
                                                                          "beta[42,1]",
                                                                          "beta[43,1]",
                                                                          "beta[44,1]",
                                                                          "beta[45,1]",
                                                                          "beta[46,1]",
                                                                          "beta[47,1]",
                                                                          "beta[48,1]",
                                                                          "beta[49,1]",
                                                                          "beta[50,1]",
                                                                          "beta[51,1]"),
                  n.iter = 1000)
```



```{r, echo = FALSE, include = F}
jags_r$BUGSoutput
```


```{r, echo = FALSE, include = F}
elec_votes_r <- c(9,9,3,6,11,55,9,7,3,29,16,4,4,20,11,6,8,8,4,10,11,16,10,6,10,3,15,3,4,14,5,6,6,29,3,18,7,7,20,4,9,3,11,38,6,13,3,12,10,5,3)

b1r <- jags_r$BUGSoutput$sims.array[1:1500]
b10r <- jags_r$BUGSoutput$sims.array[1501:3000]
b11r <- jags_r$BUGSoutput$sims.array[3001:4500]
b12r <- jags_r$BUGSoutput$sims.array[4501:6000]
b13r <- jags_r$BUGSoutput$sims.array[6001:7500]
b14r <- jags_r$BUGSoutput$sims.array[7501:9000]
b15r <- jags_r$BUGSoutput$sims.array[9001:10500]
b16r <- jags_r$BUGSoutput$sims.array[10501:12000]
b17r <- jags_r$BUGSoutput$sims.array[12001:13500]
b18r <- jags_r$BUGSoutput$sims.array[13501:15000]
b19r <- jags_r$BUGSoutput$sims.array[15001:16500]
b2r <- jags_r$BUGSoutput$sims.array[16501:18000]
b20r <- jags_r$BUGSoutput$sims.array[18001:19500]
b21r <- jags_r$BUGSoutput$sims.array[19501:21000]
b22r <- jags_r$BUGSoutput$sims.array[21001:22500]
b23r <- jags_r$BUGSoutput$sims.array[22501:24000]
b24r <- jags_r$BUGSoutput$sims.array[24001:25500]
b25r <- jags_r$BUGSoutput$sims.array[25501:27000]
b26r <- jags_r$BUGSoutput$sims.array[27001:28500]
b27r <- jags_r$BUGSoutput$sims.array[28501:30000]
b28r <- jags_r$BUGSoutput$sims.array[30001:31500]
b29r <- jags_r$BUGSoutput$sims.array[31501:33000]
b3r <- jags_r$BUGSoutput$sims.array[33001:34500]
b30r <- jags_r$BUGSoutput$sims.array[34501:36000]
b31r <- jags_r$BUGSoutput$sims.array[36001:37500]
b32r <- jags_r$BUGSoutput$sims.array[37501:39000]
b33r <- jags_r$BUGSoutput$sims.array[39001:40500]
b34r <- jags_r$BUGSoutput$sims.array[40501:42000]
b35r <- jags_r$BUGSoutput$sims.array[42001:43500]
b36r <- jags_r$BUGSoutput$sims.array[43501:45000]
b37r <- jags_r$BUGSoutput$sims.array[45001:46500]
b38r <- jags_r$BUGSoutput$sims.array[46501:48000]
b39r <- jags_r$BUGSoutput$sims.array[48001:49500]
b4r <- jags_r$BUGSoutput$sims.array[49501:51000]
b40r <- jags_r$BUGSoutput$sims.array[51001:52500]
b41r <- jags_r$BUGSoutput$sims.array[52501:54000]
b42r <- jags_r$BUGSoutput$sims.array[54001:55500]
b43r <- jags_r$BUGSoutput$sims.array[55501:57000]
b44r <- jags_r$BUGSoutput$sims.array[57001:58500]
b45r <- jags_r$BUGSoutput$sims.array[58501:60000]
b46r <- jags_r$BUGSoutput$sims.array[60001:61500]
b47r <- jags_r$BUGSoutput$sims.array[61501:63000]
b48r <- jags_r$BUGSoutput$sims.array[63001:64500]
b49r <- jags_r$BUGSoutput$sims.array[64501:66000]
b5r <- jags_r$BUGSoutput$sims.array[66001:67500]
b50r <- jags_r$BUGSoutput$sims.array[67501:69000]
b51r <- jags_r$BUGSoutput$sims.array[69001:70500]
b6r <- jags_r$BUGSoutput$sims.array[70501:72000]
b7r <- jags_r$BUGSoutput$sims.array[72001:73500]
b8r <- jags_r$BUGSoutput$sims.array[73501:75000]
b9r <- jags_r$BUGSoutput$sims.array[75001:76500]


w1 = ifelse(b1r > 50, 0, 0) # US
w2 = ifelse(b2r > 50, 3, 0) # AK
w3 = ifelse(b3r > 50, 9, 0) # AL
w4 = ifelse(b4r > 50, 11, 0) # AR
w5 = ifelse(b5r > 50, 6, 0) # AZ
w6 = ifelse(b6r > 50, 55, 0) # CA
w7 = ifelse(b7r > 50, 9, 0) # CO
w8 = ifelse(b8r > 50, 7, 0) # CT
w9 = ifelse(b9r > 50, 3, 0) # DE
w10 = ifelse(b10r > 50, 29, 0) # FL
w11 = ifelse(b11r > 50, 16, 0) # GA
w12 = ifelse(b12r > 50, 4, 0) # HI
w13 = ifelse(b13r > 50, 6, 0) # IA
w14 = ifelse(b14r > 50, 4, 0) # ID
w15 = ifelse(b15r > 50, 20, 0) # IL
w16 = ifelse(b16r > 50, 11, 0) # IN
w17 = ifelse(b17r > 50, 6, 0) # KS
w18 = ifelse(b18r > 50, 8, 0) # KY
w19 = ifelse(b19r > 50, 8, 0) # LA
w20 = ifelse(b20r > 50, 11, 0) # MA
w21 = ifelse(b21r > 50, 10, 0) # MD
w22 = ifelse(b22r > 50, 4, 0) # ME
w23 = ifelse(b23r > 50, 16, 0) # MI
w24 = ifelse(b24r > 50, 10, 0) # MN
w25 = ifelse(b25r > 50, 10, 0) # MO
w26 = ifelse(b26r > 50, 6, 0) # MS 
w27 = ifelse(b27r > 50, 3, 0) # MT
w28 = ifelse(b28r > 50, 15, 0) # NC
w29 = ifelse(b29r > 50, 3, 0) # ND
w30 = ifelse(b30r > 50, 5, 0) # NE
w31 = ifelse(b31r > 50, 4, 0) # NH
w32 = ifelse(b32r > 50, 14, 0) # NJ
w33 = ifelse(b33r > 50, 5, 0) # NM
w34 = ifelse(b34r > 50, 6, 0) # NV
w35 = ifelse(b35r > 50, 29, 0) # NY
w36 = ifelse(b36r > 50, 18, 0) # OH
w37 = ifelse(b37r > 50, 7, 0) # OK
w38 = ifelse(b38r > 50, 7, 0) # OR
w39 = ifelse(b39r > 50, 20, 0) # PA
w40 = ifelse(b40r > 50, 4, 0) # RI
w41 = ifelse(b41r > 50, 9, 0) # SC
w42 = ifelse(b42r > 50, 3, 0) # SD
w43 = ifelse(b43r > 50, 11, 0) # TN
w44 = ifelse(b44r > 50, 38, 0) # TX
w45 = ifelse(b45r > 50, 6, 0) # UT
w46 = ifelse(b46r > 50, 13, 0) # VA
w47 = ifelse(b47r > 50, 3, 0) # VT
w48 = ifelse(b48r > 50, 12, 0) # WA
w49 = ifelse(b49r > 50, 10, 0) # WI
w50 = ifelse(b50r > 50, 5, 0) # WV
w51 = ifelse(b51r > 50, 3, 0) # WY

r_wins <- data.frame(cbind(w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15, w16, w17, w18, w19, w20, w21, w22, w23, w24, w25, w26, w27, w28, w29, w30, w31,w32,w33,w34,w35,w36,w37,w38,w39,w40,w41,w42,w43,w44,w45,w46,w47,w48,w49,w50,w51))

n = nrow(r_wins)

r_wins$total = rowSums(r_wins)

clinton_electoral <- r_wins%>%
  filter(total > 269) %>%
  summarise(perc = n()/nrow(r_wins)) %>%
  pull()

clinton_electoral
```


## US Senate - 2018 Election

```{r, echo = FALSE, include = FALSE}
# 35 seats up 

s <- read.csv(file='data/senate_polls.csv')
s <- s %>%
  filter(cycle == 2018) %>%
  filter(stage != "general")

senate_polls <- read.csv(file='data/senate_polls.csv')
senate_polls <- senate_polls %>%
  mutate(days_to_election = as.Date(as.character(election_date), format ="%m/%d/%Y")-as.Date(as.character(start_date), format = "%m/%d/%Y")) %>%
  filter(cycle == 2018) %>%
  filter(race_id != 97) %>% # 2 democrats running?
  mutate(candidate_party = case_when(candidate_name == "Bernard Sanders" ~ "DEM",
                                     candidate_name == "Angus S. King Jr." ~ "DEM",
                                     TRUE ~ candidate_party)) %>% # made them democrat so numbers would line up, he often votes with Democrats on issues
  filter(stage != "jungle primary") %>%
  filter(stage != "runoff") %>%
  filter(days_to_election <= 365)%>%
  filter(candidate_party == "REP" | candidate_party == "DEM")%>%
  mutate(days_to_election = as.numeric(days_to_election)) %>%
  filter(question_id != 86679 & question_id != 91111 & question_id != 90518 & question_id != 90510 & question_id != 90151 & question_id != 85923)


polls_republican <- senate_polls %>%
  filter(candidate_party=="REP") 
r_pct = polls_republican$pct

polls_not_republican <- senate_polls %>%
  filter(candidate_party == "DEM")
d_pct = polls_not_republican$pct

polls_republican$rep_pct = 100*r_pct/(r_pct + d_pct)
```

```{r, echo = FALSE, inlcude = F}
state <- polls_republican$state %>% unique
y <- polls_republican$rep_pct
r <- match(polls_republican$state,state)
t <- polls_republican$days_to_election + 1
N_polls <- y %>% length
N_states <- state %>% length
N_days <- t %>% max
jags_data_republican <- list(y=y,t=t,r=r,
                  N_polls=N_polls,N_states=N_states,N_days=N_days)

```

```{r, echo = FALSE, inlcude = F}
model <- function(){
  for(k in 1:N_polls){
    y[k] ~ dnorm(p[k],1/sigma2_y[r[k]]) #note no longer binomial
    p[k] = beta[r[k],t[k]] 
  }
  for(j in 2:N_days){
    for(i in 1:N_states){
      beta[i,j] ~ dnorm(beta[i,j-1],pow(sigma2_beta[i],-1))
    }
  }
  
  #EXERCISE: add hierarhciacl prior for sigma2_beta and sigma2_y, i.e. sigma2_beta[j] all come from a common distribution 
  for(j in 1:N_states){
      sigma2_y[j] = 1/sigma2_y_inv[j]
      sigma2_y_inv[j] ~ dgamma(nu_y,nu_y*tau_y) 
      
      sigma2_beta[j] = 1/sigma2_beta_inv[j]
      sigma2_beta_inv[j] ~ dgamma(nu_beta,nu_beta*tau_beta) 
      
      beta[j,1] ~ dnorm(mu0,pow(sigma2_0,-1))
  }
  nu_y ~ dunif(0,100)
  tau_y ~ dunif(0,100)
  
  nu_beta ~ dunif(0,100)
  tau_beta ~ dunif(0,100)
  
  mu0 ~ dnorm(50,pow(7.5,-2))
  sigma2_0 = 1/sigma2_0_inv
  sigma2_0_inv ~ dgamma(.5,.5)
}
```



```{r, echo = F, include = F}
set.seed(1)
jags_r <- jags(data = jags_data_republican,
                  model.file = model,
                  parameters.to.save = c("beta[1,1]", "beta[2,1]", "beta[3,1]", "beta[4,1]", "beta[5,1]", 
                                         "beta[6,1]", "beta[7,1]", "beta[8,1]", "beta[9,1]", "beta[10,1]",
                                         "beta[11,1]", "beta[12,1]", "beta[13,1]", "beta[14,1]", "beta[15,1]",
                                         "beta[16,1]", "beta[17,1]", "beta[18,1]", "beta[19,1]", "beta[20,1]",
                                         "beta[21,1]", "beta[22,1]", "beta[23,1]", "beta[24,1]", "beta[25,1]",
                                         "beta[26,1]", "beta[27,1]", "beta[28,1]", "beta[29,1]", "beta[30,1]"),
                  n.iter = 1000)

b1r <- jags_r$BUGSoutput$sims.array[1:1500]
b10r <- jags_r$BUGSoutput$sims.array[1501:3000]
b11r <- jags_r$BUGSoutput$sims.array[3001:4500]
b12r <- jags_r$BUGSoutput$sims.array[4501:6000]
b13r <- jags_r$BUGSoutput$sims.array[6001:7500]
b14r <- jags_r$BUGSoutput$sims.array[7501:9000]
b15r <- jags_r$BUGSoutput$sims.array[9001:10500]
b16r <- jags_r$BUGSoutput$sims.array[10501:12000]
b17r <- jags_r$BUGSoutput$sims.array[12001:13500]
b18r <- jags_r$BUGSoutput$sims.array[13501:15000]
b19r <- jags_r$BUGSoutput$sims.array[15001:16500]
b2r <- jags_r$BUGSoutput$sims.array[16501:18000]
b20r <- jags_r$BUGSoutput$sims.array[18001:19500]
b21r <- jags_r$BUGSoutput$sims.array[19501:21000]
b22r <- jags_r$BUGSoutput$sims.array[21001:22500]
b23r <- jags_r$BUGSoutput$sims.array[22501:24000]
b24r <- jags_r$BUGSoutput$sims.array[24001:25500]
b25r <- jags_r$BUGSoutput$sims.array[25501:27000]
b26r <- jags_r$BUGSoutput$sims.array[27001:28500]
b27r <- jags_r$BUGSoutput$sims.array[28501:30000]
b28r <- jags_r$BUGSoutput$sims.array[30001:31500]
b29r <- jags_r$BUGSoutput$sims.array[31501:33000]
b3r <- jags_r$BUGSoutput$sims.array[33001:34500]
b30r <- jags_r$BUGSoutput$sims.array[34501:36000]
b4r <- jags_r$BUGSoutput$sims.array[36001:37500]
b5r <- jags_r$BUGSoutput$sims.array[37501:39000]
b6r <- jags_r$BUGSoutput$sims.array[39001:40500]
b7r <- jags_r$BUGSoutput$sims.array[40501:42000]
b8r <- jags_r$BUGSoutput$sims.array[42001:43500]
b9r <- jags_r$BUGSoutput$sims.array[43501:45000]

```

```{r, echo = FALSE, include = F}
jags_r$BUGSoutput
```


```{r, echo = FALSE, inlcude = F}
senate_1 <- read.csv(file='data/senate_polls.csv')
senate_1 %>%
  filter(question_id == 86679 | question_id == 91111 | question_id == 90518 | question_id == 90510 | question_id == 90151 | question_id == 85923)
```


```{r, echo = FALSE, include = F}
w1 = ifelse(b1r > 50, 1, 0)
w2 = ifelse(b2r > 50, 1, 0)
w3 = ifelse(b3r > 50, 1, 0)
w4 = ifelse(b4r > 50, 1, 0)
w5 = ifelse(b5r > 50, 1, 0)
w6 = ifelse(b6r > 50, 1, 0)
w7 = ifelse(b7r > 50, 1, 0)
w8 = ifelse(b8r > 50, 1, 0)
w9 = ifelse(b9r > 50, 1, 0)
w10 = ifelse(b10r > 50, 1, 0)
w11 = ifelse(b11r > 50, 1, 0)
w12 = ifelse(b12r > 50, 1, 0)
w13 = ifelse(b13r > 50, 1, 0)
w14 = ifelse(b14r > 50, 1, 0)
w15 = ifelse(b15r > 50, 1, 0)
w16 = ifelse(b16r > 50, 1, 0)
w17 = ifelse(b17r > 50, 1, 0)
w18 = ifelse(b18r > 50, 1, 0)
w19 = ifelse(b19r > 50, 1, 0)
w20 = ifelse(b20r > 50, 1, 0)
w21 = ifelse(b21r > 50, 1, 0)
w22 = ifelse(b22r > 50, 1, 0)
w23 = ifelse(b23r > 50, 1, 0)
w24 = ifelse(b24r > 50, 1, 0)
w25 = ifelse(b25r > 50, 1, 0)
w26 = ifelse(b26r > 50, 1, 0)
w27 = ifelse(b27r > 50, 1, 0)
w28 = ifelse(b28r > 50, 1, 0)
w29 = ifelse(b29r > 50, 1, 0)
w30 = ifelse(b30r > 50, 1, 0)


r_wins <- data.frame(cbind(w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15, w16, w17, w18, w19, w20, w21, w22, w23, w24, w25, w26, w27, w28, w29, w30))

n = nrow(r_wins)

#rowSums(r_wins)
r_wins$total = rowSums(r_wins)

#missing a few states, but these races aren't predicted to be close
#CALIFORNIA (D) MISSISSIPI (R) MISSISSIPPI Special (R) # Maine (D) # New Mexico (D)
# 51 R 49 D split before
# 9 R up, 26 D up
# R+6 needed more than 8 seats to keep majority

repub_senate <- r_wins%>%
  filter(total > 6) %>%
  summarise(perc = n()/nrow(r_wins)) %>%
  pull()

repub_senate

```

## NC Senate - 2016 Election
```{r echo = F, include = F}
# estimate percentages across whole state

M5 <- lmer(Republican.percentage ~ traveltime15_2010 + foreign_share2010 + singleparent_share2010 + frac_coll_plus2010 + poor_share2010 + rent_twobed2015 + ann_avg_job_growth_2004_2013 + share_white2010 + share_black2010 + share_hisp2010 + share_asian2010 +  (1|county), data = rep2018, control = lmerControl(optimizer ="Nelder_Mead"))
summary(M5)
coef(M5)

PI <- predictInterval(merMod = M5, newdata = full_counties,
                        level = 0.95, n.sims = 1000,
                        stat = "median", type="linear.prediction",
                        include.resid.var = TRUE)

# account for counties split into 2 districts
modified_counties <- full_counties %>%
  mutate(Totals = as.numeric(gsub(",","",Totals))) %>%
  mutate(voters = case_when(split == "y" ~ Totals/2,
                            TRUE ~ Totals))

modified_counties$fit = PI$fit
modified_counties$lower = PI$lwr
modified_counties$upper = PI$upr

# weight county vote share by number of people who voted in 2016 election
modified_counties %>%
  group_by(district) %>%
  summarise(dist_share_rep = sum(fit*voters)/sum(voters),
            dist_lwr_rep = sum(lower*voters)/sum(voters),
            dist_upr_rep = sum(upper*voters)/sum(voters))

modified_counties %>%
  summarise(dist_share_rep = sum(fit*voters)/sum(voters),
            dist_lwr_rep = sum(lower*voters)/sum(voters),
            dist_upr_rep = sum(upper*voters)/sum(voters))

```

## NC House of Representatives - 2016 Election
```{r multi-level-model, echo = FALSE, include = F}


# linear mixed model with random effect for county
M2 <- lmer(Republican.percentage ~ traveltime15_2010 + foreign_share2010 + singleparent_share2010 +  incumbent_party + frac_coll_plus2010 + poor_share2010 + rent_twobed2015 + ann_avg_job_growth_2004_2013 + share_white2010 + share_black2010 + share_hisp2010 + share_asian2010 +  (1|county), data = rep2016, control = lmerControl(optimizer ="Nelder_Mead"))
summary(M2)
coef(M2)

```


```{r, echo = FALSE, include= F}
PI <- predictInterval(merMod = M2, newdata = full_counties,
                        level = 0.95, n.sims = 1000,
                        stat = "median", type="linear.prediction",
                        include.resid.var = TRUE)

# account for counties split into 2 districts
modified_counties <- full_counties %>%
  mutate(Totals = as.numeric(gsub(",","",Totals))) %>%
  mutate(voters = case_when(split == "y" ~ Totals/2,
                            TRUE ~ Totals))

modified_counties$fit = PI$fit
modified_counties$lower = PI$lwr
modified_counties$upper = PI$upr

# weight county vote share by number of people who voted in 2016 election
modified_counties %>%
  group_by(district) %>%
  summarise(dist_share_rep = sum(fit*voters)/sum(voters),
            dist_lwr_rep = sum(lower*voters)/sum(voters),
            dist_upr_rep = sum(upper*voters)/sum(voters))

```